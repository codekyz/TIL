# Modern JavaScript Deep Dive 11~20

# 11장 원시 값과 객체의 비교

## 원시 타입(값)

- **변경 불가능한immutable 값, 즉 읽기전용**
- **변경 불가능하다는 것은 변수가 아니라 값에 대한 진술**
- 상수(const)는 재할당이 금지된 변수일 뿐, 변경 불가능한 값과 동일시 하면 안됨
- 이러한 원시 값의 특성은 데이터의 신뢰성을 보장(불변성)
- **불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없음**

### 문자열

- **자바스크립트의 문자열(String 객체) 또한 원시 타입이며 변경 불가능함** (문자열이 생성된 이후에는 변경할 수 없음을 의미)
- 문자열은 **유사 배열 객체이면서 이터러블**이므로 배열과 유사하게 각 문자에 접근 가능
  - 유사 배열 객체(array-like object) : 배열처럼 인덱스로 프로펕 ㅣ값에 접근할 수 있고 length 프로퍼티를 갖는 객체

### 값에 의한 전달

- 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달 => **값에 의한 전달**
- 하지만 할당받는 변수와 할당되는 변수의 값은 **다른 메모리 공간에 저장된 별개의 값**
- 따라서 값을 전달해주는 변수의 값을 변경해도 복사한 변수의 값에는 어떠한 영향도 없음
- **엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문에** 값에 의한 전달이라는 용어는 오해가 있을 수 있음(변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하기 때문)
- 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있음
- **결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없음**

## 객체

- 자바스크립트 객체의 관리 방식 : 자바스크립트 객체는 **프로퍼티 키를 인덱스로 사용하는 해시 테이블**이라고 생각할 수 있음, 또한 V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 **동적탐색 대신 히든 클래스라는 방식을 사용해 성능을 보장**

### 변경 가능한 값

- **객체(참조)타입의 값, 즉 객체는 변경 가능한mutable 값**
- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조reference 값(생성된 객체가 저장된 메모리 공간의 주소, 그 자체)** 에 접근
- 그리고 메모리에 저장되어 있는 **참조 값을 통해 실제 객체에 접근**
- 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있음
- **객체의 부작용 : 여러 개의 식별자가 하나의 객체를 공유할 수 있음(참조에 의한 전달)**

#### 얕은shallow 복사와 깊은deep 복사

- 객체를 프로퍼티 값으로 갖는 객체의 경우
- 얕은 복사 : 한 단계까지만 복사하는 것
- 깊은 복사 : 객체에 중접되어 있는 객체까지 모두 복사하는 것
- **얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체, 즉 참조 값이 다른 별개의 객체**
- 참고로 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사, 객체를 하랑한 변수를 다른 변수에 할당하는 것을 얕은 복사라고 부르는 경우도 있음

### 참조에 의한 전달

- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값이 복사되어 전달** => **참조에 의한 전달**
- 두개의 변수, 두개의 식별자가 하나의 객체를 공유
- 결국 **값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일**
- 따라서 자바스크립트에는 **참조에 의한 전달은 존재하지 않고 값에 의한 전달만이 존재한다고 말할 수 있음(포인터 개념이 없기때문에)**
- **전달되는 값의 종류가 원시 값인지 참조 값인지 구별**해서 강조하는 의미에서 값에 의한 전달/참조에 의한 전달로 구분

# 12장 함수

## 함수란?

- 자바스크립트에서 가장 중요한 핵심 개념
- **일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것**
- 함수 정의를 통해 생성하고 인자와 함께 함수 호출을 통해 반환값을 반환

## 함수를 사용하는 이유

- 코드의 재사용
- 유지보수의 편의성
- 코드의 신뢰성
- 코드의 가독성

## 함수 리터럴

- 함수는 객체 타입의 값으로 함수 리터럴로 생성 **(함수 === 객체)**
- 함수 리터럴 : function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성
- **일반 객체는 호출할 수 없지만 함수는 호출할 수 있음**

## 함수 정의

- 함수를 호출하기 이전에 인수에 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것
- 정의된 함수는 엔진에 의해 평가되어 함수 객체가 됨
  ### 함수 정의하는 방법
  - **함수 선언문** : function add(x, y) { return x+y; }
    - 이름생략 불가, 표현식X 문O
    - **자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당**
    - 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출
  - **함수 표현식** : var add = function(x, y) { return x+y; };
    - 자바스크립트 함수는 일급 객체
    - 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있음
    - 일반적으로 이름 생략, 표현식O 문O
      > 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점은 다름
  - Function 생성자 함수 : var add = new Function('x', 'y', 'return x + y');
    - new 연산자 없이 호출해도 동일
    - 이러한 방식으로 생성된 함수는 클로저를 생성하지 않는 등 다르게 동작함
  - 화살표 함수(ES6) : var add = (x, y) => x + y;
    - 표현만 간략할 뿐만 아니라 내부 동작 또한 간략화됨(26장에서 설명)
- 변수는 선언, 함수는 정의
- **함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라고함**
- **함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생(표현식 이전에 참조하면 undefined를 반환)**

## 함수 호출

- 함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출

  ### 매개변수와 인수

  - 매개변수는 함수를 정의할 때 선언하며 함수 내부에서 변수와 동일하게 취급
  - 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않음
  - 따라서 **인수가 부족해서 인수가 할당되지 않은 매개변수 값은 undefined, 초과된 값은 무시**

  ### 인수 확인

  - 자바스크립트는 동적 타이핑 언어로 매개변수의 타입을 사전에 지정할 수 없음
  - 따라서 **함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있음**

  ### 매개변수의 최대 개수

  - **이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야함**
  - 따라서 **매개변수는 최대 3개 이상을 넘지 않는 것을 권장**
  - 다수의 매개변수가 필요하다면 객체로 인수를 전달하는 것이 유리
    - 주의할 것은 함수 외부에서 내부로 전달한 객체를 함수 내부에서 변경하면 외부의 객체가 변경되는 부수 효과가 발생

  ### 반환문

  - 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나감
  - 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환(명시적으로 지정하지 않으면 undefined가 반환)

## 참조에 의한 전달과 외부 상태의 변경

- 매개변수 또한 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따름
- **객체타입 인수는 참조 값이 복사되어 매개변수에 전달 되기 때문에 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 훼손됨**

## 다양한 함수의 형태

- **즉시 실행 함수(IIFE)**

  - 함수 정의와 동시에 즉시 호출되는 함수로 단 한 번만 호출됨
  - 익명 함수를 사용하는 것이 일반적
  - 즉시 실행 함수는 반드시 그룹 연산자 (...)로 감싸야 함 `(function () { ... }());`

  ```
  // 즉시 실행 함수도 일반 함수처럼 인수를 전달할 수 있음
  res = (function (a, b) {
    return a * b;
  }(3, 5));
  ```

- **재귀 함수**

  - 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말함
  - 재귀 함수는 자신을 무한 재귀 호출 함, 따라서 재귀 호출을 멈출 수 있는 **탈출 조건**을 만드시 만들어야함(스택 오버플로 에러 발생)
  - 특수한 상황에 한정적으로 사용하는 것이 바람직

- **중첩 함수**

  - 함수 내부에 정의된 함수를 **중첩 함수 도는 내부 함수** 라고 함
  - 중첩 함수를 포함하는 함수는 **외부 함수**
  - 일반적으로 중첩 함수는 **자신을 포함하는 외부함수를 돕는 헬퍼 함수의 역할을 함**

- **콜백 함수**

  - 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 **콜백 함수**라고함
  - 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 **고차 함수(HOF)** 라고 함
  - 즉, **고차 함수는 콜백 함수를 자신의 일부분으로 합성함**
  - 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출
  - 콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달
  - **콜백 함수는 함수형 프로그래밍 패러다임뿐만 아니라 비동기 처리(이벤트, ajax, 타이머 함수 등)에 활용되는 중요한 패턴**

- **순수 함수와 비순수 함수**
  - 순수 함수 : 어떤 외부 상태에 의존하지도 변경하지도 않는, 부수 효과가 없는 함수
  - 비순수 함수 : 부수 효과가 있는 함수
  - 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임

# 13장 스코프

- 스코프(유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념
- var 키워드로 선언한 변수와 let 또는 const 키워드로 선언한 변수의 스코프는 다르게 동작
  - var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용
- **모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정 됨 => 스코프 === 식별자가 유효한 범위**
- **식별자를 검색(결정)할 때 사용하는 규칙 => 스코프**
- 스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있음 즉, **스코프는 네임스페이스**

## 렉시컬lexical 환경

- 코드가 어디서 실행되며 주변에 어떤 코드가 있는지
- 즉, 코드의 문맥context는 렉시컬 환경으로 이루어짐 => 이를 구현한 것이 **실행 컨텍스트**(23장)

## 스코프의 종류

- 전역global : 코드의 가장 바깥 영역, 전역 스코프, 전역 변수
  - 전역 변수는 어디서든지 참조할 수 있음
- 지역local : 함수 몸체 내부, 지역 스코프, 지역 변수
  - 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효

## 스코프 체인

- 함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있음 => **스코프가 함수의 중첩에 의해 계층적 구조를 갖는다는 것을 의미**
- **스코프 체인 === 모든 스코프는 하나의 계층적 구조로 연결 되며 모든 지역스코프의 최상위 스코프는 전역 스코프**
- 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색함
  - 따라서 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조할 수 있음
  - 스코프 체인으로 연결된 스코프의 계층적 구조는 **부자 관계로 이뤄진 상속과 유사함**(부모의 자산을 자식이 사용할 수 있지만 반대는 불가능)

## 함수 레벨 스코프

- **함수 레벨 스코프 => 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성됨**
  - var 키워드로 선언된 변수는오로지 함수의 코드 블록만을 지역 스코프로 인정(함수 레벨 스코프)
- 블록 레벨 스코프 => 모든 코드 블록이 지역 스코프를 만듬
  - ES6에서 도입된 **let과 const 키워드는 블록 레벨 스코프를 지원**

## 렉시컬 스코프

- **렉시컬 스코프(정적 스코프) <=> 동적 스코프**
- **함수를 어디서 정의했는지에 따라 상위 스코프를 결정,** 호출된 위치는 스코프 결정에 어떠한 영향도 주지 않음

# 14장 전역 변수의 문제점

## 변수의 생명 주기

- **지역 변수의 생명 주기**

  - 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸
  - 변수 호이스팅은 엄밀히 말해서 전역변수에 한정된 것
  - **지역 변수의 생명 주기는 함수의 생명 주기와 일치**
  - 스코프는 누군가 참조하고 있다면 해제되지 않고 생존함(24장 클로저)
  - **호이스팅은 스코프 단위로 동작 => 지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작**
  - 즉, **호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징**

- **전역 변수의 생명 주기**

  - 전역 객체 : 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다 먼저 생성되는 특수한 객체로 CS환경에서는 window, SS환경에서는 global객체를 의미
  - **var 키워드로 선언한 전역 변수의 생명주기는 전역 객체의 생명주기와 일치**

## 전역 변수의 문제점

- **암묵적 결합** : 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것
- **긴 생명주기** : 전역 변수는 생명 주기가 길어 메모리 리소스도 오랜 기간 소비하고 상태 변경에 의한 오류 발생확률이 높음
- **스코프 체인 상에서 종점에 존재** : 전역 변수의 검색 속도가 가장 느림
- **네임스페이스 오염** : 자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것. 따라서 다른 파일 내에서 동일한 이름으로 명명될 경우 예상치 못한 결과를 가져 올수 있음

## 전역 변수 사용을 억제하는 방법

- 전역 변수를 반드시 사용해야할 이유를 찾지 못한다면 지역 변수를 사용
- 변수의 스코프는 좁을수록 좋음
- **즉시 실행 함수** : 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됨
- **모듈 패턴** : 클래스를 모방해서 관련 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈로 만듬. 클로저를 기반으로 동작하며 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있음
- **ES6 모듈** : **ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공**, var 키워드로 선언해도 더는 전역 변수도 window객체의 프로퍼티도 아님(모던 브라우저에서 사용)
  - `<script type="module" src="lib.mjs"></script>`

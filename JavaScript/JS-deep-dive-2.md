# Modern JavaScript Deep Dive 11~20

# 11장 원시 값과 객체의 비교

## 원시 타입(값)

- **변경 불가능한immutable 값, 즉 읽기전용**
- **변경 불가능하다는 것은 변수가 아니라 값에 대한 진술**
- 상수(const)는 재할당이 금지된 변수일 뿐, 변경 불가능한 값과 동일시 하면 안됨
- 이러한 원시 값의 특성은 데이터의 신뢰성을 보장(불변성)
- **불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없음**

### 문자열

- **자바스크립트의 문자열(String 객체) 또한 원시 타입이며 변경 불가능함** (문자열이 생성된 이후에는 변경할 수 없음을 의미)
- 문자열은 **유사 배열 객체이면서 이터러블**이므로 배열과 유사하게 각 문자에 접근 가능
  - 유사 배열 객체(array-like object) : 배열처럼 인덱스로 프로펕 ㅣ값에 접근할 수 있고 length 프로퍼티를 갖는 객체

### 값에 의한 전달

- 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달 => **값에 의한 전달**
- 하지만 할당받는 변수와 할당되는 변수의 값은 **다른 메모리 공간에 저장된 별개의 값**
- 따라서 값을 전달해주는 변수의 값을 변경해도 복사한 변수의 값에는 어떠한 영향도 없음
- **엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문에** 값에 의한 전달이라는 용어는 오해가 있을 수 있음(변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하기 때문)
- 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있음
- **결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없음**

## 객체

- 자바스크립트 객체의 관리 방식 : 자바스크립트 객체는 **프로퍼티 키를 인덱스로 사용하는 해시 테이블**이라고 생각할 수 있음, 또한 V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 **동적탐색 대신 히든 클래스라는 방식을 사용해 성능을 보장**

### 변경 가능한 값

- **객체(참조)타입의 값, 즉 객체는 변경 가능한mutable 값**
- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조reference 값(생성된 객체가 저장된 메모리 공간의 주소, 그 자체)** 에 접근
- 그리고 메모리에 저장되어 있는 **참조 값을 통해 실제 객체에 접근**
- 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있음
- **객체의 부작용 : 여러 개의 식별자가 하나의 객체를 공유할 수 있음(참조에 의한 전달)**

#### 얕은shallow 복사와 깊은deep 복사

- 객체를 프로퍼티 값으로 갖는 객체의 경우
- 얕은 복사 : 한 단계까지만 복사하는 것
- 깊은 복사 : 객체에 중접되어 있는 객체까지 모두 복사하는 것
- **얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체, 즉 참조 값이 다른 별개의 객체**
- 참고로 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사, 객체를 하랑한 변수를 다른 변수에 할당하는 것을 얕은 복사라고 부르는 경우도 있음

### 참조에 의한 전달

- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값이 복사되어 전달** => **참조에 의한 전달**
- 두개의 변수, 두개의 식별자가 하나의 객체를 공유
- 결국 **값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일**
- 따라서 자바스크립트에는 **참조에 의한 전달은 존재하지 않고 값에 의한 전달만이 존재한다고 말할 수 있음(포인터 개념이 없기때문에)**
- **전달되는 값의 종류가 원시 값인지 참조 값인지 구별**해서 강조하는 의미에서 값에 의한 전달/참조에 의한 전달로 구분

# 12장 함수

## 함수란?

- 자바스크립트에서 가장 중요한 핵심 개념
- **일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것**
- 함수 정의를 통해 생성하고 인자와 함께 함수 호출을 통해 반환값을 반환

## 함수를 사용하는 이유

- 코드의 재사용
- 유지보수의 편의성
- 코드의 신뢰성
- 코드의 가독성

## 함수 리터럴

- 함수는 객체 타입의 값으로 함수 리터럴로 생성 **(함수 === 객체)**
- 함수 리터럴 : function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성
- **일반 객체는 호출할 수 없지만 함수는 호출할 수 있음**

## 함수 정의

- 함수를 호출하기 이전에 인수에 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것
- 정의된 함수는 엔진에 의해 평가되어 함수 객체가 됨
  ### 함수 정의하는 방법
  - **함수 선언문** : function add(x, y) { return x+y; }
    - 이름생략 불가, 표현식X 문O
    - **자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당**
    - 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출
  - **함수 표현식** : var add = function(x, y) { return x+y; };
    - 자바스크립트 함수는 일급 객체
    - 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있음
    - 일반적으로 이름 생략, 표현식O 문O
      > 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점은 다름
  - Function 생성자 함수 : var add = new Function('x', 'y', 'return x + y');
    - new 연산자 없이 호출해도 동일
    - 이러한 방식으로 생성된 함수는 클로저를 생성하지 않는 등 다르게 동작함
  - 화살표 함수(ES6) : var add = (x, y) => x + y;
    - 표현만 간략할 뿐만 아니라 내부 동작 또한 간략화됨(26장에서 설명)
- 변수는 선언, 함수는 정의
- **함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라고함**
- **함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생(표현식 이전에 참조하면 undefined를 반환)**

## 함수 호출

- 함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출

  ### 매개변수와 인수

  - 매개변수는 함수를 정의할 때 선언하며 함수 내부에서 변수와 동일하게 취급
  - 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않음
  - 따라서 **인수가 부족해서 인수가 할당되지 않은 매개변수 값은 undefined, 초과된 값은 무시**

  ### 인수 확인

  - 자바스크립트는 동적 타이핑 언어로 매개변수의 타입을 사전에 지정할 수 없음
  - 따라서 **함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있음**

  ### 매개변수의 최대 개수

  - **이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야함**
  - 따라서 **매개변수는 최대 3개 이상을 넘지 않는 것을 권장**
  - 다수의 매개변수가 필요하다면 객체로 인수를 전달하는 것이 유리
    - 주의할 것은 함수 외부에서 내부로 전달한 객체를 함수 내부에서 변경하면 외부의 객체가 변경되는 부수 효과가 발생

  ### 반환문

  - 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나감
  - 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환(명시적으로 지정하지 않으면 undefined가 반환)

## 참조에 의한 전달과 외부 상태의 변경

- 매개변수 또한 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따름
- **객체타입 인수는 참조 값이 복사되어 매개변수에 전달 되기 때문에 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 훼손됨**

## 다양한 함수의 형태

- **즉시 실행 함수(IIFE)**

  - 함수 정의와 동시에 즉시 호출되는 함수로 단 한 번만 호출됨
  - 익명 함수를 사용하는 것이 일반적
  - 즉시 실행 함수는 반드시 그룹 연산자 (...)로 감싸야 함 `(function () { ... }());`

  ```
  // 즉시 실행 함수도 일반 함수처럼 인수를 전달할 수 있음
  res = (function (a, b) {
    return a * b;
  }(3, 5));
  ```

- **재귀 함수**

  - 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말함
  - 재귀 함수는 자신을 무한 재귀 호출 함, 따라서 재귀 호출을 멈출 수 있는 **탈출 조건**을 만드시 만들어야함(스택 오버플로 에러 발생)
  - 특수한 상황에 한정적으로 사용하는 것이 바람직

- **중첩 함수**

  - 함수 내부에 정의된 함수를 **중첩 함수 도는 내부 함수** 라고 함
  - 중첩 함수를 포함하는 함수는 **외부 함수**
  - 일반적으로 중첩 함수는 **자신을 포함하는 외부함수를 돕는 헬퍼 함수의 역할을 함**

- **콜백 함수**

  - 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 **콜백 함수**라고함
  - 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 **고차 함수(HOF)** 라고 함
  - 즉, **고차 함수는 콜백 함수를 자신의 일부분으로 합성함**
  - 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출
  - 콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달
  - **콜백 함수는 함수형 프로그래밍 패러다임뿐만 아니라 비동기 처리(이벤트, ajax, 타이머 함수 등)에 활용되는 중요한 패턴**

- **순수 함수와 비순수 함수**
  - 순수 함수 : 어떤 외부 상태에 의존하지도 변경하지도 않는, 부수 효과가 없는 함수
  - 비순수 함수 : 부수 효과가 있는 함수
  - 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임
